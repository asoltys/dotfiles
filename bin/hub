#!/usr/bin/env ruby
#
# This file, hub, is generated code.
# Please DO NOT EDIT or send patches for it.
#
# Please take a look at the source from
# http://github.com/defunkt/hub
# and submit patches against the individual files
# that build hub.
#

module Hub
  class Runner
    attr_reader :args
    
    def initialize(*args)
      @args = Args.new(args)
      Commands.run(@args)
    end

    def self.execute(*args)
      new(*args).execute
    end

    def command
      if args.skip?
        ''
      else
        commands.join('; ')
      end
    end

    def commands
      args.commands.map do |cmd|
        if cmd.respond_to?(:join)
          cmd.map { |arg| arg = arg.to_s; (arg.index(' ') || arg.empty?) ? "'#{arg}'" : arg }.join(' ')
        else
          cmd.to_s
        end
      end
    end

    def execute
      if args.noop?
        puts commands
      elsif not args.skip?
        if args.chained?
          execute_command_chain
        else
          exec(*args.to_exec)
        end
      end
    end

    def execute_command_chain
      commands = args.commands
      commands.each_with_index do |cmd, i|
        if cmd.respond_to?(:call) then cmd.call
        elsif i == commands.length - 1
          exec(*cmd)
        else
          exit($?.exitstatus) unless system(*cmd)
        end
      end
    end
  end
end
module Hub
  module Context; end

  module Commands
    instance_methods.each { |m| undef_method(m) unless m =~ /(^__|send|to\?$)/ }
    extend self

    extend Context

    API_REPO        = 'http://github.com/api/v2/yaml/repos/show/%s/%s'
    API_FORK        = 'https://github.com/api/v2/yaml/repos/fork/%s/%s'
    API_CREATE      = 'https://github.com/api/v2/yaml/repos/create'
    API_PULLREQUEST = 'https://github.com/api/v2/yaml/pulls/%s/%s'

    def run(args)
      slurp_global_flags(args)

      args.unshift 'help' if args.empty?

      cmd = args[0]
      expanded_args = expand_alias(cmd)
      cmd = expanded_args[0] if expanded_args

      cmd = cmd.sub(/(\w)-/, '\1_')
      if method_defined?(cmd) and cmd != 'run'
        args[0, 1] = expanded_args if expanded_args
        send(cmd, args)
      end
    rescue Errno::ENOENT
      if $!.message.include? "No such file or directory - git"
        abort "Error: `git` command not found"
      else
        raise
      end
    end

    def pull_request(args)
      args.shift
      options = { }
      force = explicit_owner = false
      base_repo = origin_repo

      while arg = args.shift
        case arg
        when '-f'
          force = true
        when '-b'
          options[:base] = Context::Ref.from_github_ref(args.shift, origin_repo)
        when '-h'
          head = args.shift
          explicit_owner = !!head.index(':')
          options[:head] = Context::Ref.from_github_ref(head, current_repo)
        when %r{^https?://github.com/([^/]+/[^/]+)/issues/(\d+)}
          options[:issue] = $2
          base_repo = Context::Repo.from_string($1)
        when %r{^#(\d+)$}
          options[:issue] = $1
        else
          if !options[:title] then options[:title] = arg
          else
            abort "invalid argument: #{arg}"
          end
        end
      end

      options[:base] ||= base_repo.ref_for('master')
      options[:head] ||= upstream_ref(current_branch, current_repo) ||
        current_repo.ref_for(normalize_branch(current_branch))

      if head_repo = options[:head].repo and head_repo.owner != github_user and not explicit_owner
        options[:head].repo = head_repo.from_owner(github_user)
      end

      if not force and not explicit_owner and local_commits = Context::GIT_CONFIG["rev-list --cherry #{options[:head].to_local_ref}..."]
        $stderr.puts "Aborted: #{local_commits.split("\n").size} commits are not yet pushed to #{options[:head].to_local_ref}"
        warn "(use `-f` to force submit a pull request anyway)"
        abort
      end

      unless options[:title] or options[:issue]
        changes = Context::GIT_CONFIG["log --no-color --pretty=medium --cherry %s...%s" %
          [options[:base].to_local_ref, options[:head].to_local_ref]]

        options[:title], options[:body] = pullrequest_editmsg(changes) { |msg|
          msg.puts "# You're requesting a pull to #{options[:base].to_github_ref} from #{options[:head].to_github_ref}"
        }
      end

      pull = create_pullrequest(options)

      args.executable = 'echo'
      args.replace [pull['html_url']]
    rescue HTTPExceptions
      display_http_exception("creating pull request", $!.response)
      exit 1
    end

    def clone(args)
      ssh = args.delete('-p')
      has_values = /^(--(upload-pack|template|depth|origin|branch|reference)|-[ubo])$/

      idx = 1
      while idx < args.length
        arg = args[idx]
        if arg.index('-') == 0
          idx += 1 if arg =~ has_values
        elsif arg.index('://') or arg.index('@') or File.directory?(arg)
          break
        elsif arg.scan('/').size <= 1 && !arg.include?(':')
          args[args.index(arg)] = github_url(:repo => arg, :private => ssh)
          break
        end
        idx += 1
      end
    end

    def submodule(args)
      return unless index = args.index('add')
      args.delete_at index

      branch = args.index('-b') || args.index('--branch')
      if branch
        args.delete_at branch
        branch_name = args.delete_at branch
      end

      clone(args)

      if branch_name
        args.insert branch, '-b', branch_name
      end
      args.insert index, 'add'
    end

    def remote(args)
      return unless ['add','set-url'].include?(args[1]) && args.last !~ %r{.+?://|.+?@|^[./]}

      ssh = args.delete('-p')

      args.last =~ /\b(.+?)(?:\/(.+))?$/
      user, repo = $1, $2

      if args.words[2] == 'origin' && args.words[3].nil?
        user = repo = nil
      elsif args.words[-2] == args.words[1]
        idx = args.index( args.words[-1] )
        args[idx] = user
      else
        args.replace args[0...-1]
      end

      args << github_url(:user => user, :repo => repo, :private => ssh)
    end

    def fetch(args)
      if args.include?('--multiple')
        names = args.words[1..-1]
      elsif remote_name = args.words[1]
        if remote_name =~ /^\w+(,\w+)+$/
          index = args.index(remote_name)
          args.delete(remote_name)
          names = remote_name.split(',')
          args.insert(index, *names)
          args.insert(index, '--multiple')
        else
          names = [remote_name]
        end
      else
        names = []
      end

      names.reject! { |name|
        name =~ /\W/ or remotes.include?(name) or
          remotes_group(name) or not repo_exists?(name)
      }

      if names.any?
        names.each do |name|
          args.before ['remote', 'add', name, github_url(:user => name)]
        end
      end
    end

    def cherry_pick(args)
      unless args.include?('-m') or args.include?('--mainline')
        case ref = args.words.last
        when %r{^(?:https?:)//github.com/(.+?)/(.+?)/commit/([a-f0-9]{7,40})}
          user, repo, sha = $1, $2, $3
          args[args.index(ref)] = sha
        when /^(\w+)@([a-f0-9]{7,40})$/
          user, repo, sha = $1, nil, $2
          args[args.index(ref)] = sha
        else
          user = nil
        end

        if user
          if user == repo_owner
            args.before ['fetch', default_remote]
          elsif remotes.include?(user)
            args.before ['fetch', user]
          else
            remote_url = github_url(:user => user, :repo => repo, :private => false)
            args.before ['remote', 'add', '-f', user, remote_url]
          end
        end
      end
    end

    def am(args)
      if url = args.find { |a| a =~ %r{^https?://(gist\.)?github\.com/} }
        idx = args.index(url)
        gist = $1 == 'gist.'
        url = url.sub(%r{(/pull/\d+)/\w*$}, '\1') unless gist
        ext = gist ? '.txt' : '.patch'
        url += ext unless File.extname(url) == ext
        patch_file = File.join(ENV['TMPDIR'], "#{gist ? 'gist-' : ''}#{File.basename(url)}")
        args.before 'curl', ['-#LA', "hub #{Hub::Version}", url, '-o', patch_file]
        args[idx] = patch_file
      end
    end

    alias_method :apply, :am

    def init(args)
      if args.delete('-g')
        url = github_url(:private => true, :repo => current_dirname)
        args.after ['remote', 'add', 'origin', url]
      end
    end

    def fork(args)
      if github_user && github_token && repo_owner
        if repo_exists?(github_user)
          warn "#{github_user}/#{repo_name} already exists on GitHub"
        else
          fork_repo
        end

        if args.include?('--no-remote')
          exit
        else
          url = github_url(:private => true)
          args.replace %W"remote add -f #{github_user} #{url}"
          args.after 'echo', ['new remote:', github_user]
        end
      end
    rescue HTTPExceptions
      display_http_exception("creating fork", $!.response)
      exit 1
    end

    def create(args)
      if !is_repo?
        abort "'create' must be run from inside a git repository"
      elsif owner = github_user and github_token
        args.shift
        options = {}
        options[:private] = true if args.delete('-p')
        new_repo_name = nil

        until args.empty?
          case arg = args.shift
          when '-d'
            options[:description] = args.shift
          when '-h'
            options[:homepage] = args.shift
          else
            if arg =~ /^[^-]/ and new_repo_name.nil?
              new_repo_name = arg
              owner, new_repo_name = new_repo_name.split('/', 2) if new_repo_name.index('/')
            else
              abort "invalid argument: #{arg}"
            end
          end
        end
        new_repo_name ||= repo_name
        repo_with_owner = "#{owner}/#{new_repo_name}"

        if repo_exists?(owner, new_repo_name)
          warn "#{repo_with_owner} already exists on GitHub"
          action = "set remote origin"
        else
          action = "created repository"
          create_repo(repo_with_owner, options)
        end

        url = github_url(:repo => new_repo_name, :user => owner, :private => true)

        if remotes.first != 'origin'
          args.replace %W"remote add -f origin #{url}"
        else
          args.replace %W"remote -v"
        end

        args.after 'echo', ["#{action}:", repo_with_owner]
      end
    rescue HTTPExceptions
      display_http_exception("creating repository", $!.response)
      exit 1
    end

    def push(args)
      return if args[1].nil? || !args[1].index(',')

      branch  = (args[2] ||= normalize_branch(current_branch))
      remotes = args[1].split(',')
      args[1] = remotes.shift

      remotes.each do |name|
        args.after ['push', name, branch]
      end
    end

    def browse(args)
      args.shift
      browse_command(args) do
        user = repo = nil
        dest = args.shift
        dest = nil if dest == '--'

        if dest
          repo = dest
        elsif repo_user
          user = repo_user
        else
          abort "Usage: hub browse [<USER>/]<REPOSITORY>"
        end

        params = { :user => user, :repo => repo }

        case subpage = args.shift
        when 'commits'
          branch = (!dest && tracked_branch) || 'master'
          params[:web] = "/commits/#{branch}"
        when 'tree', NilClass
          branch = !dest && tracked_branch
          params[:web] = "/tree/#{branch}" if branch && branch != 'master'
        else
          params[:web] = "/#{subpage}"
        end

        params
      end
    end

    def compare(args)
      args.shift
      browse_command(args) do
        if args.empty?
          branch = tracked_branch
          if branch && branch != 'master'
            range, user = branch, repo_user
          else
            abort "Usage: hub compare [USER] [<START>...]<END>"
          end
        else
          sha_or_tag = /(\w{1,2}|\w[\w.-]+\w)/
          range = args.pop.sub(/^#{sha_or_tag}\.\.#{sha_or_tag}$/, '\1...\2')
          user = args.pop || repo_user
        end
        { :user => user, :web => "/compare/#{range}" }
      end
    end

    def hub(args)
      return help(args) unless args[1] == 'standalone'
      require 'hub/standalone'
      $stdout.puts Hub::Standalone.build
      exit
    rescue LoadError
      abort "hub is running in standalone mode."
    end

    def alias(args)
      shells = {
        'sh'   => 'alias git=hub',
        'bash' => 'alias git=hub',
        'zsh'  => 'function git(){hub "$@"}',
        'csh'  => 'alias git hub',
        'fish' => 'alias git hub'
      }

      silent = args.delete('-s')

      if shell = args[1]
        if silent.nil?
          puts "Run this in your shell to start using `hub` as `git`:"
          print "  "
        end
      else
        puts "usage: hub alias [-s] SHELL", ""
        puts "You already have hub installed and available in your PATH,"
        puts "but to get the full experience you'll want to alias it to"
        puts "`git`.", ""
        puts "To see how to accomplish this for your shell, run the alias"
        puts "command again with the name of your shell.", ""
        puts "Known shells:"
        shells.map { |key, _| key }.sort.each do |key|
          puts "  " + key
        end
        puts "", "Options:"
        puts "  -s   Silent. Useful when using the output with eval, e.g."
        puts "       $ eval `hub alias -s bash`"

        exit
      end

      if shells[shell]
        puts shells[shell]
      else
        abort "fatal: never heard of `#{shell}'"
      end

      exit
    end

    def version(args)
      args.after 'echo', ['hub version', Version]
    end
    alias_method "--version", :version

    def help(args)
      command = args.words[1]

      if command == 'hub'
        puts hub_manpage
        exit
      elsif command.nil? && !args.has_flag?('-a', '--all')
        ENV['GIT_PAGER'] = '' unless args.has_flag?('-p', '--paginate') # Use `cat`.
        puts improved_help_text
        exit
      end
    end
    alias_method "--help", :help

    def improved_help_text
      <<-help
usage: git [--version] [--exec-path[=GIT_EXEC_PATH]] [--html-path]
    [-p|--paginate|--no-pager] [--bare] [--git-dir=GIT_DIR]
    [--work-tree=GIT_WORK_TREE] [--help] COMMAND [ARGS]

Basic Commands:
   init       Create an empty git repository or reinitialize an existing one
   add        Add new or modified files to the staging area
   rm         Remove files from the working directory and staging area
   mv         Move or rename a file, a directory, or a symlink
   status     Show the status of the working directory and staging area
   commit     Record changes to the repository

History Commands:
   log        Show the commit history log
   diff       Show changes between commits, commit and working tree, etc
   show       Show information about commits, tags or files

Branching Commands:
   branch     List, create, or delete branches
   checkout   Switch the active branch to another branch
   merge      Join two or more development histories (branches) together
   tag        Create, list, delete, sign or verify a tag object

Remote Commands:
   clone      Clone a remote repository into a new directory
   fetch      Download data, tags and branches from a remote repository
   pull       Fetch from and merge with another repository or a local branch
   push       Upload data, tags and branches to a remote repository
   remote     View and manage a set of remote repositories

Advanced commands:
   reset      Reset your staging area or working directory to another point
   rebase     Re-apply a series of patches in one branch onto another
   bisect     Find by binary search the change that introduced a bug
   grep       Print files with lines matching a pattern in your codebase

See 'git help COMMAND' for more information on a specific command.
help
    end

  private

    def slurp_global_flags(args)
      flags = %w[ --noop -c -p --paginate --no-pager --no-replace-objects --bare --version --help ]
      flags2 = %w[ --exec-path= --git-dir= --work-tree= ]

      globals = []
      locals = []

      while args[0] && (flags.include?(args[0]) || flags2.any? {|f| args[0].index(f) == 0 })
        flag = args.shift
        case flag
        when '--noop'
          args.noop!
        when '--version', '--help'
          args.unshift flag.sub('--', '')
        when '-c'
          config_pair = args.shift
          key, value = config_pair.split('=', 2)
          Context::GIT_CONFIG["config #{key}"] = value.to_s

          globals << flag << config_pair
        when '-p', '--paginate', '--no-pager'
          locals << flag
        else
          globals << flag
        end
      end

      Context::GIT_CONFIG.executable = Array(Context::GIT_CONFIG.executable).concat(globals)
      args.executable = Array(args.executable).concat(globals).concat(locals)
    end

    def browse_command(args)
      url_only = args.delete('-u')
      warn "Warning: the `-p` flag has no effect anymore" if args.delete('-p')
      params = yield

      args.executable = url_only ? 'echo' : browser_launcher
      args.push github_url({:web => true}.update(params))
    end

    def hub_manpage
      abort "** Can't find groff(1)" unless command?('groff')

      require 'open3'
      out = nil
      Open3.popen3(groff_command) do |stdin, stdout, _|
        stdin.puts hub_raw_manpage
        stdin.close
        out = stdout.read.strip
      end
      out
    end

    def groff_command
      "groff -Wall -mtty-char -mandoc -Tascii"
    end

    def hub_raw_manpage
      if File.exists? file = File.dirname(__FILE__) + '/../../man/hub.1'
        File.read(file)
      else
        DATA.read
      end
    end

    def puts(*args)
      page_stdout
      super
    end

    def page_stdout
      return if not $stdout.tty? or windows?

      read, write = IO.pipe

      if Kernel.fork
        $stdin.reopen(read)
        read.close
        write.close

        ENV['LESS'] = 'FSRX'

        Kernel.select [STDIN]

        pager = ENV['GIT_PAGER'] ||
          `git config --get-all core.pager`.split.first || ENV['PAGER'] ||
          'less -isr'

        pager = 'cat' if pager.empty?

        exec pager rescue exec "/bin/sh", "-c", pager
      else
        $stdout.reopen(write)
        $stderr.reopen(write) if $stderr.tty?
        read.close
        write.close
      end
    end

    def repo_exists?(user, repo = repo_name)
      load_net_http
      url = API_REPO % [user, repo]
      Net::HTTPSuccess === Net::HTTP.get_response(URI(url))
    end

    def fork_repo
      load_net_http
      response = http_post API_FORK % [repo_owner, repo_name]
      response.error! unless Net::HTTPSuccess === response
    end

    def create_repo(name, options = {})
      params = {'name' => name.sub(/^#{github_user}\//, '')}
      params['public'] = '0' if options[:private]
      params['description'] = options[:description] if options[:description]
      params['homepage'] = options[:homepage] if options[:homepage]

      load_net_http
      response = http_post(API_CREATE, params)
      response.error! unless Net::HTTPSuccess === response
    end

    def create_pullrequest(options)
      base_repo = options.fetch(:base).repo
      params = {
        'pull[base]' => options[:base].branch,
        'pull[head]' => options.fetch(:head).to_github_ref
      }
      params['pull[issue]'] = options[:issue] if options[:issue]
      params['pull[title]'] = options[:title] if options[:title]
      params['pull[body]'] = options[:body] if options[:body]

      load_net_http
      response = http_post(API_PULLREQUEST % [base_repo.owner, base_repo.name], params)
      response.error! unless Net::HTTPSuccess === response
      require 'yaml'
      YAML.load(response.body)['pull']
    end

    def pullrequest_editmsg(changes)
      message_file = File.join(git_dir, 'PULLREQ_EDITMSG')
      File.open(message_file, 'w') { |msg|
        msg.puts
        yield msg
        if changes
          msg.puts "#\n# Changes:\n#"
          msg.puts changes.gsub(/^/, '# ')
        end
      }
      edit_cmd = Array(git_editor).dup << message_file
      system(*edit_cmd)
      abort "can't open text editor for pull request message" unless $?.success?
      title, body = read_editmsg(message_file)
      abort "Aborting due to empty pull request title" unless title
      [title, body]
    end

    def read_editmsg(file)
      title, body = '', ''
      File.open(file, 'r') { |msg|
        msg.each_line do |line|
          next if line.index('#') == 0
          ((body.empty? and line =~ /\S/) ? title : body) << line
        end
      }
      title.tr!("\n", ' ')
      title.strip!
      body.strip!
      
      [title =~ /\S/ ? title : nil, body =~ /\S/ ? body : nil]
    end

    def expand_alias(cmd)
      if expanded = git_alias_for(cmd)
        if expanded.index('!') != 0
          require 'shellwords' unless defined?(::Shellwords)
          Shellwords.shellwords(expanded)
        end
      end
    end

    def http_post(url, params = nil)
      url = URI(url)
      post = Net::HTTP::Post.new(url.request_uri)
      post.basic_auth "#{github_user}/token", github_token
      post.set_form_data params if params

      port = url.port
      if use_ssl = 'https' == url.scheme and not use_ssl?
        use_ssl = false
        port = 80
      end

      http = Net::HTTP.new(url.host, port)
      if http.use_ssl = use_ssl
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end
      http.start { http.request(post) }
    end

    def load_net_http
      require 'net/https'
    rescue LoadError
      require 'net/http'
    end

    def use_ssl?
      defined? ::OpenSSL
    end

    module HTTPExceptions
      def self.===(exception)
        exception.class.ancestors.map {|a| a.to_s }.include? 'Net::HTTPExceptions'
      end
    end

    def display_http_exception(action, response)
      $stderr.puts "Error #{action}: #{response.message} (HTTP #{response.code})"
      warn "Check your token configuration (`git config github.token`)" if response.code.to_i == 401
    end

  end
end
module Hub
  Version = VERSION = '1.6.1'
end
module Hub
  class Args < Array
    attr_accessor :executable

    def initialize(*args)
      super
      @executable = ENV["GIT"] || "git"
      @after = nil
      @skip = @noop = false
      @original_args = args.first
      @chain = [nil]
    end

    def after(cmd_or_args = nil, args = nil, &block)
      @chain.insert(-1, normalize_callback(cmd_or_args, args, block))
    end

    def before(cmd_or_args = nil, args = nil, &block)
      @chain.insert(@chain.index(nil), normalize_callback(cmd_or_args, args, block))
    end

    def chained?
      @chain.size > 1
    end

    def commands
      chain = @chain.dup
      chain[chain.index(nil)] = self.to_exec
      chain
    end

    def skip!
      @skip = true
    end

    def skip?
      @skip
    end

    def noop!
      @noop = true
    end

    def noop?
      @noop
    end

    def to_exec(args = self)
      Array(executable) + args
    end

    def words
      reject { |arg| arg.index('-') == 0 }
    end

    def flags
      self - words
    end

    def changed?
      chained? or self != @original_args
    end

    def has_flag?(*flags)
      pattern = flags.flatten.map { |f| Regexp.escape(f) }.join('|')
      !grep(/^#{pattern}(?:=|$)/).empty?
    end

    private

    def normalize_callback(cmd_or_args, args, block)
      if block
        block
      elsif args
        [cmd_or_args].concat args
      elsif Array === cmd_or_args
        self.to_exec cmd_or_args
      elsif cmd_or_args
        cmd_or_args
      else
        raise ArgumentError, "command or block required"
      end
    end
  end
end
require 'shellwords'

module Hub
  module Context
    private

    class ShellOutCache < Hash
      attr_accessor :executable

      def initialize(executable = nil, &block)
        super(&block)
        @executable = executable
      end

      def to_exec(args)
        args = Shellwords.shellwords(args) if args.respond_to? :to_str
        Array(executable) + Array(args)
      end
    end

    NULL = defined?(File::NULL) ? File::NULL : File.exist?('/dev/null') ? '/dev/null' : 'NUL'

    GIT_CONFIG = ShellOutCache.new(ENV['GIT'] || 'git') do |cache, cmd|
      full_cmd = cache.to_exec(cmd)
      cmd_string = full_cmd.respond_to?(:shelljoin) ? full_cmd.shelljoin : full_cmd.join(' ')
      result = %x{#{cmd_string} 2>#{NULL}}.chomp
      cache[cmd] = $?.success? && !result.empty? ? result : nil
    end

    REMOTES = Hash.new do |cache, remote|
      if remote
        urls = GIT_CONFIG["config --get-all remote.#{remote}.url"].to_s.split("\n")

        if urls.find { |u| u =~ %r{\bgithub\.com[:/](.+)/(.+).git$} } 
          cache[remote] = { :user => $1, :repo => $2 }
        else
          cache[remote] = { }
        end
      else
        cache[remote] = { }
      end
    end

    LGHCONF = "http://help.github.com/git-email-settings/"

    def repo_owner
      if repo = origin_repo
        repo.owner
      end
    end

    def repo_user
      if repo = current_repo
        repo.owner
      end
    end

    def repo_name
      if repo = origin_repo
        repo.name
      else
        current_dirname
      end
    end

    def origin_repo
      if remote = default_remote
        remote.repo
      end
    end

    def current_repo
      if remote = current_remote
        remote.repo
      end
    end

    class Remote < Struct.new(:name)
      def self.all
        @remotes ||= begin
          list = GIT_CONFIG['remote'].to_s.split("\n")
          main = list.delete('origin') and list.unshift(main)
          list.map { |name| new(name) }
        end
      end

      def self.clear!
        remove_instance_variable '@remotes' if defined? @remotes
      end

      def self.origin
        all.first
      end

      def self.by_name(remote_name)
        all.find {|r| r.name == remote_name }
      end

      def self.for_repo(repo)
        all.find {|r| r.repo == repo }
      end

      alias to_s name

      def ==(other)
        other.respond_to?(:to_str) ? name == other.to_str : super
      end

      def repo
        return @repo if defined? @repo
        @repo = if urls.find { |u| u =~ %r{\bgithub\.com[:/](.+)/(.+).git$} } 
          Repo.new($1, $2)
        end
      end

      def urls
        @urls ||= GIT_CONFIG["config --get-all remote.#{name}.url"].to_s.split("\n")
      end
    end

    class Repo < Struct.new(:owner, :name)
      def self.from_string(str, context_repo = nil)
        if str.index('/')
          new(*str.split('/', 2))
        else
          new(str, context_repo.name)
        end
      end

      def from_owner(another_owner, another_name = nil)
        self.class.new(another_owner, another_name || self.name)
      end

      def ref_for(branch)
        Ref.new(self, branch)
      end
    end

    class Ref < Struct.new(:repo, :branch, :remote)
      def self.from_github_ref(branch, context_repo)
        if branch.index(':')
          owner_with_name, branch = branch.split(':', 2)
          context_repo = context_repo.from_owner(*owner_with_name.split('/', 2))
        end
        new(context_repo, branch)
      end

      def self.upstream_for(branch, repo = nil)
        if GIT_CONFIG["name-rev #{branch}@{upstream} --name-only --refs='refs/remotes/*' --no-undefined"] =~ %r{^remotes/(.+)}
          remote_name, branch = $1.split('/', 2)
          new(repo, branch, Remote.by_name(remote_name))
        end
      end

      def initialize(*args)
        super
        if remote.nil?
          self.remote = Remote.for_repo(repo)
        elsif repo.nil?
          self.repo = remote.repo
        end
      end

      def to_local_ref
        "#{remote}/#{branch}"
      end

      def to_github_ref
        "#{repo.owner}:#{branch}"
      end
    end

    def github_user(fatal = true)
      if user = ENV['GITHUB_USER'] || GIT_CONFIG['config github.user']
        user
      elsif fatal
        abort("** No GitHub user set. See #{LGHCONF}")
      end
    end

    def github_token(fatal = true)
      if token = ENV['GITHUB_TOKEN'] || GIT_CONFIG['config github.token']
        token
      elsif fatal
        abort("** No GitHub token set. See #{LGHCONF}")
      end
    end

    def current_branch
      GIT_CONFIG['symbolic-ref -q HEAD']
    end

    def upstream_ref(branch, repo = nil)
      Ref.upstream_for(normalize_branch(branch), repo)
    end

    def tracked_branch
      current_branch and ref = upstream_ref(current_branch) and ref.branch
    end

    def remotes
      Remote.all
    end

    def remotes_group(name)
      GIT_CONFIG["config remotes.#{name}"]
    end

    def current_remote
      return if remotes.empty?
      (ref = current_branch && upstream_ref(current_branch)) and ref.remote or default_remote
    end

    def default_remote
      Remote.origin
    end

    def normalize_branch(branch)
      branch.sub('refs/heads/', '')
    end

    def http_clone?
      GIT_CONFIG['config --bool hub.http-clone'] == 'true'
    end

    def https_protocol?
      GIT_CONFIG['config hub.protocol'] == 'https' or http_clone?
    end

    def git_alias_for(name)
      GIT_CONFIG["config alias.#{name}"]
    end

    def github_url(options = {})
      repo = options[:repo]
      user, repo = repo.split('/') if repo && repo.index('/')
      user ||= options[:user] || github_user
      repo ||= repo_name

      if options[:web]
        path = options[:web] == true ? '' : options[:web].to_s
        if repo =~ /\.wiki$/
          repo = repo.sub(/\.wiki$/, '')
          unless '/wiki' == path
            path = '/wiki%s' % if path =~ %r{^/commits/} then '/_history'
              else path.sub(/\w+/, '_\0')
              end
          end
        end
        'https://github.com/%s/%s%s' % [user, repo, path]
      else
        if https_protocol?
          url = 'https://github.com/%s/%s.git'
        elsif options[:private]
          url = 'git@github.com:%s/%s.git'
        else
          url = 'git://github.com/%s/%s.git'
        end

        url % [user, repo]
      end
    end

    DIRNAME = File.basename(Dir.pwd)

    def current_dirname
      DIRNAME
    end

    def git_dir
      GIT_CONFIG['rev-parse --git-dir']
    end

    def is_repo?
      !!git_dir
    end

    def git_editor
      editor = GIT_CONFIG['var GIT_EDITOR']
      editor = ENV[$1] if editor =~ /^\$(\w+)$/
      editor = File.expand_path editor if (editor =~ /^[~.]/ or editor.index('/')) and editor !~ /["']/
      editor.shellsplit
    end

    def browser_launcher
      browser = ENV['BROWSER'] || (
        osx? ? 'open' : windows? ? 'start' :
        %w[xdg-open cygstart x-www-browser firefox opera mozilla netscape].find { |comm| which comm }
      )

      abort "Please set $BROWSER to a web launcher to use this command." unless browser
      Array(browser)
    end

    def osx?
      require 'rbconfig'
      RbConfig::CONFIG['host_os'].to_s.include?('darwin')
    end

    def windows?
      require 'rbconfig'
      RbConfig::CONFIG['host_os'] =~ /msdos|mswin|djgpp|mingw|windows/
    end

    def which(cmd)
      exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
      ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
        exts.each { |ext|
          exe = "#{path}/#{cmd}#{ext}"
          return exe if File.executable? exe
        }
      end
      return nil
    end

    def command?(name)
      !which(name).nil?
    end
  end
end
Hub::Runner.execute(*ARGV)
__END__
.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "HUB" "1" "October 2011" "DEFUNKT" "Git Manual"
.
.SH "NAME"
\fBhub\fR \- git + hub = github
.
.SH "SYNOPSIS"
\fBhub\fR [\fB\-\-noop\fR] \fICOMMAND\fR \fIOPTIONS\fR
.
.br
\fBhub alias\fR [\fB\-s\fR] \fISHELL\fR
.
.P
\fBgit init \-g\fR \fIOPTIONS\fR
.
.br
\fBgit create\fR [\fINAME\fR] [\fB\-p\fR] [\fB\-d\fR \fIDESCRIPTION\fR] [\fB\-h\fR \fIHOMEPAGE\fR]
.
.br
\fBgit clone\fR [\fB\-p\fR] \fIOPTIONS\fR [\fIUSER\fR/]\fIREPOSITORY\fR \fIDIRECTORY\fR
.
.br
\fBgit remote add\fR [\fB\-p\fR] \fIOPTIONS\fR \fIUSER\fR[/\fIREPOSITORY\fR]
.
.br
\fBgit remote set\-url\fR [\fB\-p\fR] \fIOPTIONS\fR \fIREMOTE\-NAME\fR \fIUSER\fR[/\fIREPOSITORY\fR]
.
.br
\fBgit fetch\fR \fIUSER\-1\fR,[\fIUSER\-2\fR,\.\.\.]
.
.br
\fBgit cherry\-pick\fR \fIGITHUB\-REF\fR
.
.br
\fBgit am\fR \fIGITHUB\-URL\fR
.
.br
\fBgit apply\fR \fIGITHUB\-URL\fR
.
.br
\fBgit push\fR \fIREMOTE\-1\fR,\fIREMOTE\-2\fR,\.\.\.,\fIREMOTE\-N\fR [\fIREF\fR]
.
.br
\fBgit browse\fR [\fB\-u\fR] [[\fIUSER\fR\fB/\fR]\fIREPOSITORY\fR] [SUBPAGE]
.
.br
\fBgit compare\fR [\fB\-u\fR] [\fIUSER\fR] [\fISTART\fR\.\.\.]\fIEND\fR
.
.br
\fBgit submodule add\fR [\fB\-p\fR] \fIOPTIONS\fR [\fIUSER\fR/]\fIREPOSITORY\fR \fIDIRECTORY\fR
.
.br
\fBgit fork\fR [\fB\-\-no\-remote\fR]
.
.br
\fBgit pull\-request\fR [\fB\-f\fR] [\fITITLE\fR] [\fB\-b\fR \fIBASE\fR] [\fB\-h\fR \fIHEAD\fR]
.
.SH "DESCRIPTION"
\fBhub\fR enhances various \fBgit\fR commands with GitHub remote expansion\. The alias command displays information on configuring your environment:
.
.IP "\(bu" 4
\fBhub \-\-noop\fR \fICOMMAND\fR: Shows which command(s) would be run as a result of the current command\. Doesn\'t perform anything\.
.
.IP "\(bu" 4
\fBhub alias\fR [\fB\-s\fR] \fISHELL\fR: Writes shell aliasing code for \fISHELL\fR (\fBbash\fR, \fBsh\fR, \fBzsh\fR, \fBcsh\fR) to standard output\. With the \fB\-s\fR option, the output of this command can be evaluated directly within the shell:
.
.br
\fBeval $(hub alias \-s bash)\fR
.
.IP "\(bu" 4
\fBgit init\fR \fB\-g\fR \fIOPTIONS\fR: Create a git repository as with git\-init(1) and add remote \fBorigin\fR at "git@github\.com:\fIUSER\fR/\fIREPOSITORY\fR\.git"; \fIUSER\fR is your GitHub username and \fIREPOSITORY\fR is the current working directory\'s basename\.
.
.IP "\(bu" 4
\fBgit create\fR [\fINAME\fR] [\fB\-p\fR] [\fB\-d\fR \fIDESCRIPTION\fR] [\fB\-h\fR \fIHOMEPAGE\fR]:
.
.br
Create a new public GitHub repository from the current git repository and add remote \fBorigin\fR at "git@github\.com:\fIUSER\fR/\fIREPOSITORY\fR\.git"; \fIUSER\fR is your GitHub username and \fIREPOSITORY\fR is the current working directory name\. To explicitly name the new repository, pass in \fINAME\fR, optionally in \fIORGANIZATION\fR/\fINAME\fR form to create under an organization you\'re a member of\. With \fB\-p\fR, create a private repository, and with \fB\-d\fR and \fB\-h\fR set the repository\'s description and homepage URL, respectively\.
.
.IP "\(bu" 4
\fBgit clone\fR [\fB\-p\fR] \fIOPTIONS\fR [\fIUSER\fR\fB/\fR]\fIREPOSITORY\fR \fIDIRECTORY\fR:
.
.br
Clone repository "git://github\.com/\fIUSER\fR/\fIREPOSITORY\fR\.git" into \fIDIRECTORY\fR as with git\-clone(1)\. When \fIUSER\fR/ is omitted, assumes your GitHub login\. With \fB\-p\fR, use private remote "git@github\.com:\fIUSER\fR/\fIREPOSITORY\fR\.git"\.
.
.IP "\(bu" 4
\fBgit remote add\fR [\fB\-p\fR] \fIOPTIONS\fR \fIUSER\fR[\fB/\fR\fIREPOSITORY\fR]:
.
.br
Add remote "git://github\.com/\fIUSER\fR/\fIREPOSITORY\fR\.git" as with git\-remote(1)\. When /\fIREPOSITORY\fR is omitted, the basename of the current working directory is used\. With \fB\-p\fR, use private remote "git@github\.com:\fIUSER\fR/\fIREPOSITORY\fR\.git"\. If \fIUSER\fR is "origin" then uses your GitHub login\.
.
.IP "\(bu" 4
\fBgit remote set\-url\fR [\fB\-p\fR] \fIOPTIONS\fR \fIREMOTE\-NAME\fR \fIUSER\fR[/\fIREPOSITORY\fR]
.
.br
Sets the url of remote \fIREMOTE\-NAME\fR using the same rules as \fBgit remote add\fR\.
.
.IP "\(bu" 4
\fBgit fetch\fR \fIUSER\-1\fR,[\fIUSER\-2\fR,\.\.\.]: Adds missing remote(s) with \fBgit remote add\fR prior to fetching\. New remotes are only added if they correspond to valid forks on GitHub\.
.
.IP "\(bu" 4
\fBgit cherry\-pick\fR \fIGITHUB\-REF\fR: Cherry\-pick a commit from a fork using either full URL to the commit or GitHub\-flavored Markdown notation, which is \fBuser@sha\fR\. If the remote doesn\'t yet exist, it will be added\. A \fBgit fetch <user>\fR is issued prior to the cherry\-pick attempt\.
.
.IP "\(bu" 4
\fBgit [am|apply]\fR \fIGITHUB\-URL\fR: Downloads the patch file for the pull request or commit at the URL and applies that patch from disk with \fBgit am\fR or \fBgit apply\fR\. Similar to \fBcherry\-pick\fR, but doesn\'t add new remotes\. \fBgit am\fR creates commits while preserving authorship info while \fBapply\fR only applies the patch to the working copy\.
.
.IP "\(bu" 4
\fBgit push\fR \fIREMOTE\-1\fR,\fIREMOTE\-2\fR,\.\.\.,\fIREMOTE\-N\fR [\fIREF\fR]: Push \fIREF\fR to each of \fIREMOTE\-1\fR through \fIREMOTE\-N\fR by executing multiple \fBgit push\fR commands\.
.
.IP "\(bu" 4
\fBgit browse\fR [\fB\-u\fR] [[\fIUSER\fR\fB/\fR]\fIREPOSITORY\fR] [SUBPAGE]: Open repository\'s GitHub page in the system\'s default web browser using \fBopen(1)\fR or the \fBBROWSER\fR env variable\. If the repository isn\'t specified, \fBbrowse\fR opens the page of the repository found in the current directory\. If SUBPAGE is specified, the browser will open on the specified subpage: one of "wiki", "commits", "issues" or other (the default is "tree")\.
.
.IP "\(bu" 4
\fBgit compare\fR [\fB\-u\fR] [\fIUSER\fR] [\fISTART\fR\.\.\.]\fIEND\fR: Open a GitHub compare view page in the system\'s default web browser\. \fISTART\fR to \fIEND\fR are branch names, tag names, or commit SHA1s specifying the range of history to compare\. If a range with two dots (\fBa\.\.b\fR) is given, it will be transformed into one with three dots\. If \fISTART\fR is omitted, GitHub will compare against the base branch (the default is "master")\.
.
.IP "\(bu" 4
\fBgit submodule add\fR [\fB\-p\fR] \fIOPTIONS\fR [\fIUSER\fR/]\fIREPOSITORY\fR \fIDIRECTORY\fR:
.
.br
Submodule repository "git://github\.com/\fIUSER\fR/\fIREPOSITORY\fR\.git" into \fIDIRECTORY\fR as with git\-submodule(1)\. When \fIUSER\fR/ is omitted, assumes your GitHub login\. With \fB\-p\fR, use private remote "git@github\.com:\fIUSER\fR/\fIREPOSITORY\fR\.git"\.
.
.IP "\(bu" 4
\fBgit fork\fR [\fB\-\-no\-remote\fR]: Forks the original project (referenced by "origin" remote) on GitHub and adds a new remote for it under your username\. Requires \fBgithub\.token\fR to be set (see CONFIGURATION)\.
.
.IP "\(bu" 4
\fBgit pull\-request\fR [\fB\-f\fR] [\fITITLE\fR] [\fB\-b\fR \fIBASE\fR] [\fB\-h\fR \fIHEAD\fR]:
.
.br
Opens a pull request on GitHub for the project that the "origin" remote points to\. The default head of the pull request is the current branch\. Both base and head of the pull request can be explicitly given in one of the following formats: "branch", "owner:branch", "owner/repo:branch"\. This command will abort operation if it detects that the current topic branch has local commits that are not yet pushed to its upstream branch on the remote\. To skip this check, use \fB\-f\fR\.
.
.IP
If \fITITLE\fR is omitted, a text editor will open in which title and body of the pull request can be entered in the same manner as git commit message\.
.
.IP
If instead of normal \fITITLE\fR a string in "#\fINUMBER\fR" format is given, the pull request will be attached to an existing GitHub issue whose ID corresponds to \fINUMBER\fR\.
.
.IP "\(bu" 4
\fBgit help\fR: Display enhanced git\-help(1)\.
.
.IP "" 0
.
.SH "CONFIGURATION"
Use git\-config(1) to display the currently configured GitHub username:
.
.IP "" 4
.
.nf

$ git config \-\-global github\.user
.
.fi
.
.IP "" 0
.
.P
Or, set the GitHub username and token with:
.
.IP "" 4
.
.nf

$ git config \-\-global github\.user <username>
$ git config \-\-global github\.token <token>
.
.fi
.
.IP "" 0
.
.P
You can override these values with \fIGITHUB_USER\fR and \fIGITHUB_TOKEN\fR environment variables\.
.
.P
See \fIhttp://github\.com/guides/local\-github\-config\fR for more information\.
.
.P
If you prefer the HTTPS protocol for GitHub repositories, you can set "hub\.protocol" to "https"\. This will affect \fBclone\fR, \fBfork\fR, \fBremote add\fR and other operations that expand references to GitHub repositories as full URLs that otherwise use git and ssh protocols\.
.
.IP "" 4
.
.nf

$ git config \-\-global hub\.protocol https
.
.fi
.
.IP "" 0
.
.SH "EXAMPLES"
.
.SS "git clone"
.
.nf

$ git clone schacon/ticgit
> git clone git://github\.com/schacon/ticgit\.git

$ git clone \-p schacon/ticgit
> git clone git@github\.com:schacon/ticgit\.git

$ git clone resque
> git clone git://github\.com/YOUR_USER/resque\.git

$ git clone \-p resque
> git clone git@github\.com:YOUR_USER/resque\.git
.
.fi
.
.SS "git remote add"
.
.nf

$ git remote add rtomayko
> git remote add rtomayko git://github\.com/rtomayko/CURRENT_REPO\.git

$ git remote add \-p rtomayko
> git remote add rtomayko git@github\.com:rtomayko/CURRENT_REPO\.git

$ git remote add origin
> git remote add origin git://github\.com/YOUR_USER/CURRENT_REPO\.git
.
.fi
.
.SS "git fetch"
.
.nf

$ git fetch mislav
> git remote add mislav git://github\.com/mislav/REPO\.git
> git fetch mislav

$ git fetch mislav,xoebus
> git remote add mislav \.\.\.
> git remote add xoebus \.\.\.
> git fetch \-\-multiple mislav xoebus
.
.fi
.
.SS "git cherry\-pick"
.
.nf

$ git cherry\-pick http://github\.com/mislav/REPO/commit/SHA
> git remote add \-f mislav git://github\.com/mislav/REPO\.git
> git cherry\-pick SHA

$ git cherry\-pick mislav@SHA
> git remote add \-f mislav git://github\.com/mislav/CURRENT_REPO\.git
> git cherry\-pick SHA

$ git cherry\-pick mislav@SHA
> git fetch mislav
> git cherry\-pick SHA
.
.fi
.
.SS "git am, git apply"
.
.nf

$ git am https://github\.com/defunkt/hub/pull/55
> curl https://github\.com/defunkt/hub/pull/55\.patch \-o /tmp/55\.patch
> git am /tmp/55\.patch

$ git am \-\-ignore\-whitespace https://github\.com/davidbalbert/hub/commit/fdb9921
> curl https://github\.com/davidbalbert/hub/commit/fdb9921\.patch \-o /tmp/fdb9921\.patch
> git am \-\-ignore\-whitespace /tmp/fdb9921\.patch

$ git apply https://gist\.github\.com/8da7fb575debd88c54cf
> curl https://gist\.github\.com/8da7fb575debd88c54cf\.txt \-o /tmp/gist\-8da7fb575debd88c54cf\.txt
> git apply /tmp/gist\-8da7fb575debd88c54cf\.txt
.
.fi
.
.SS "git fork"
.
.nf

$ git fork
[ repo forked on GitHub ]
> git remote add \-f YOUR_USER git@github\.com:YOUR_USER/CURRENT_REPO\.git
.
.fi
.
.SS "git pull\-request"
.
.nf

# while on a topic branch called "feature":
$ git pull\-request
[ opens text editor to edit title & body for the request ]
[ opened pull request on GitHub for "YOUR_USER:feature" ]

# explicit title, pull base & head:
$ git pull\-request "I\'ve implemented feature X" \-b defunkt:master \-h mislav:feature

$ git pull\-request #123
[ attached pull request to issue #123 ]
.
.fi
.
.SS "git create"
.
.nf

$ git create
[ repo created on GitHub ]
> git remote add origin git@github\.com:YOUR_USER/CURRENT_REPO\.git

# with description:
$ git create \-d \'It shall be mine, all mine!\'

$ git create recipes
[ repo created on GitHub ]
> git remote add origin git@github\.com:YOUR_USER/recipes\.git

$ git create sinatra/recipes
[ repo created in GitHub organization ]
> git remote add origin git@github\.com:sinatra/recipes\.git
.
.fi
.
.SS "git init"
.
.nf

$ git init \-g
> git init
> git remote add origin git@github\.com:YOUR_USER/REPO\.git
.
.fi
.
.SS "git push"
.
.nf

$ git push origin,staging,qa bert_timeout
> git push origin bert_timeout
> git push staging bert_timeout
> git push qa bert_timeout
.
.fi
.
.SS "git browse"
.
.nf

$ git browse
> open https://github\.com/YOUR_USER/CURRENT_REPO

$ git browse \-\- commit/SHA
> open https://github\.com/YOUR_USER/CURRENT_REPO/commit/SHA

$ git browse \-\- issues
> open https://github\.com/YOUR_USER/CURRENT_REPO/issues

$ git browse schacon/ticgit
> open https://github\.com/schacon/ticgit

$ git browse schacon/ticgit commit/SHA
> open https://github\.com/schacon/ticgit/commit/SHA

$ git browse resque
> open https://github\.com/YOUR_USER/resque

$ git browse resque network
> open https://github\.com/YOUR_USER/resque/network
.
.fi
.
.SS "git compare"
.
.nf

$ git compare refactor
> open https://github\.com/CURRENT_REPO/compare/refactor

$ git compare 1\.0\.\.1\.1
> open https://github\.com/CURRENT_REPO/compare/1\.0\.\.\.1\.1

$ git compare \-u fix
> (https://github\.com/CURRENT_REPO/compare/fix)

$ git compare other\-user patch
> open https://github\.com/other\-user/REPO/compare/patch
.
.fi
.
.SS "git submodule"
.
.nf

$ hub submodule add wycats/bundler vendor/bundler
> git submodule add git://github\.com/wycats/bundler\.git vendor/bundler

$ hub submodule add \-p wycats/bundler vendor/bundler
> git submodule add git@github\.com:wycats/bundler\.git vendor/bundler

$ hub submodule add \-b ryppl ryppl/pip vendor/pip
> git submodule add \-b ryppl git://github\.com/ryppl/pip\.git vendor/pip
.
.fi
.
.SS "git help"
.
.nf

$ git help
> (improved git help)
$ git help hub
> (hub man page)
.
.fi
.
.SH "BUGS"
\fIhttp://github\.com/defunkt/hub/issues\fR
.
.SH "AUTHORS"
\fIhttps://github\.com/defunkt/hub/contributors\fR
.
.SH "SEE ALSO"
git(1), git\-clone(1), git\-remote(1), git\-init(1), \fIhttp://github\.com\fR, \fIhttp://github\.com/defunkt/hub\fR
